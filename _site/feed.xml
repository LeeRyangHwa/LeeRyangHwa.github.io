<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-11-16T06:27:12+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Dot com factory</title><subtitle></subtitle><author><name>SW Factory Owner</name></author><entry><title type="html">JPA에 대한 소개</title><link href="http://localhost:4000/spring-jpa-chapter1/" rel="alternate" type="text/html" title="JPA에 대한 소개" /><published>2020-11-16T00:00:00+00:00</published><updated>2020-11-16T21:06:00+00:00</updated><id>http://localhost:4000/spring-jpa-chapter1</id><content type="html" xml:base="http://localhost:4000/spring-jpa-chapter1/">&lt;h2 id=&quot;jpa에-대한-소개&quot;&gt;JPA에 대한 소개&lt;/h2&gt;

&lt;p&gt;객체와 관계형 데이터 베이스 간의 차이를 중간에서 해결해 주는 ORM 프레임워크가 있다. JPA는 이러한 자바 진영의 ORM 기술 표준이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JPA를 사용해서 얻는 가장 큰 성과는 SQL이 아닌 객체 중심으로 개발하니 생산성과 유지보수가 확연히 좋아졌고 테스트를 작성하기도 편해진 점이다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;sql을-직접-다룰-때-발생하는-문제점&quot;&gt;SQL을 직접 다룰 때 발생하는 문제점&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;진정한 의미의 계층 분할이 어렵다.&lt;/li&gt;
  &lt;li&gt;엔티티를 신뢰할 수 없다.&lt;/li&gt;
  &lt;li&gt;SQL에 의존적인 개발을 피하기 어렵다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;JPA를 이용한다면 개발자가 직접 SQL를 작성하는 것이 아니라 JPA에서 제공하는 API를 사용하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;객체와-관계형-데이터베이스의-패러다임-불일치-문제&quot;&gt;객체와 관계형 데이터베이스의 패러다임 불일치 문제&lt;/h3&gt;

&lt;p&gt;객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르므로 둘의 기능과 표현 방법도 다르다. 이것을 패러다임 불일치 문제라 한다.&lt;/p&gt;

&lt;h3 id=&quot;패러다임의-불일치로-인해-발생하는-문제&quot;&gt;패러다임의 불일치로 인해 발생하는 문제&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;객체는 상속이라는 기능을 가지고 있지만 테이블은 상속이라는 기능이 없다.
    &lt;ul&gt;
      &lt;li&gt;작성해야 할 코드량이 많다.&lt;/li&gt;
      &lt;li&gt;테이블을 조인 후 그 결과로 다른 객체를 생성해야한다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;⇒ JPA는 자바 컬렉션에 객체를 저장하듯이 JPA에게 객체를 저장하면 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;객체는 참조를 사용해 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회하지만 테이블은 외래 키를 사용해서 조회한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;객체 그래프 탐색&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;참조를 사용해서 연관된 팀을 찾는 것 ( 객체 그래프 탐색 )&lt;/p&gt;

&lt;p&gt;⇒ SQL을 직접 다루면 객체 그래프를 어디까지 탐색할 수 있을지 정해진다.
JPA는 객체지향 개발자에게 힘든 이러한 작업을 쉽게 할 수 있도록 도와준다.
연관된 객체를 사용하는 시점에 적절한 Select SQL실행 (지연로딩)&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jpa&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getOrder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getOrderDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;JPA와 비교&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;100&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jpa&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jpa&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;member1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;member2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//같다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;jpa란&quot;&gt;JPA란?&lt;/h2&gt;

&lt;p&gt;자바 진영의 ORM 기술 표준이다.&lt;/p&gt;

&lt;p&gt;ORM이란?&lt;br /&gt;
객체와 관계형 데이터 베이스를 매핑한다는 뜻
ORM 프레임워크는 단순히 SQL을 개발자 대신 생성해서 데이터베이스에 전달 해주는 것 뿐만 아니라 다양한 패러다임의 불일치 문제들도 해결&lt;/p&gt;

&lt;h2 id=&quot;jpa를-사용해야-하는-이유&quot;&gt;JPA를 사용해야 하는 이유&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;생산성
  JPA를 사용하면 자바 컬렉션에서 객체를 저장하듯이 JPA에게 저장 할 객체를 전달하면 된다.  ⇒ 지루하고 반복적인 일을 대신 처리해줌&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;유지보수
  엔티티에 필드를 하나만 추가해도 관련된 등록, 수정, 조회를 위해 코드를 변경을 위해 코드를 모두 변경할 필요가 없다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;패러다임의 불일치 해결
  JPA는 상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 패러다임의 문제를 해결&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;성능
  애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;데이터 접근 추상화와 벤더 독립성
  관계형 데이터베이스는 같은 기능도 벤더마다 사용법이 다른 경우가 많아 사용법을 각각 배워야하는 문제점을 JPA가 해결해준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;표준
  JPA는 자바진영의 ORM기술 표본이기 때문에 다른 구현 기술로 손쉽게 변경가능&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SW Factory Owner</name></author><summary type="html">JPA에 대한 소개</summary></entry><entry><title type="html">github.io 블로그 시작하기</title><link href="http://localhost:4000/first-post/" rel="alternate" type="text/html" title="github.io 블로그 시작하기" /><published>2020-11-10T00:00:00+00:00</published><updated>2020-11-10T21:06:00+00:00</updated><id>http://localhost:4000/first-post</id><content type="html" xml:base="http://localhost:4000/first-post/">&lt;p&gt;GitHub Blog 서비스 테스트
GitHub Blog 시작&lt;/p&gt;</content><author><name>SW Factory Owner</name></author><summary type="html">GitHub Blog 서비스인 github.io 블로그 시작</summary></entry></feed>