---
title: "JPA에 대한 소개"
excerpt: "JPA에 대한 소개"

categories:
  - Spring
tags:
  - JPA

date: 2020-11-16
toc: true
toc_label: "JPA에 대한 소개"
toc_sticky: true
---


## JPA에 대한 소개

객체와 관계형 데이터 베이스 간의 차이를 중간에서 해결해 주는 ORM 프레임워크가 있다. JPA는 이러한 자바 진영의 ORM 기술 표준이다.

**JPA를 사용해서 얻는 가장 큰 성과는 SQL이 아닌 객체 중심으로 개발하니 생산성과 유지보수가 확연히 좋아졌고 테스트를 작성하기도 편해진 점이다.**

## SQL을 직접 다룰 때 발생하는 문제점

1. 진정한 의미의 계층 분할이 어렵다.
2. 엔티티를 신뢰할 수 없다.
3. SQL에 의존적인 개발을 피하기 어렵다.

JPA를 이용한다면 개발자가 직접 SQL를 작성하는 것이 아니라 JPA에서 제공하는 API를 사용하면 된다. 

### 객체와 관계형 데이터베이스의 패러다임 불일치 문제

객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르므로 둘의 기능과 표현 방법도 다르다. 이것을 패러다임 불일치 문제라 한다.

### 패러다임의 불일치로 인해 발생하는 문제

1. 객체는 상속이라는 기능을 가지고 있지만 테이블은 상속이라는 기능이 없다.
    - 작성해야 할 코드량이 많다.
    - 테이블을 조인 후 그 결과로 다른 객체를 생성해야한다.

    ⇒ JPA는 자바 컬렉션에 객체를 저장하듯이 JPA에게 객체를 저장하면 된다.

2. 객체는 참조를 사용해 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회하지만 테이블은 외래 키를 사용해서 조회한다.

3. 객체 그래프 탐색

참조를 사용해서 연관된 팀을 찾는 것 ( 객체 그래프 탐색 )

⇒ SQL을 직접 다루면 객체 그래프를 어디까지 탐색할 수 있을지 정해진다.
JPA는 객체지향 개발자에게 힘든 이러한 작업을 쉽게 할 수 있도록 도와준다.
연관된 객체를 사용하는 시점에 적절한 Select SQL실행 (지연로딩)

```java
Member member = jpa.find(Member.class, memberId);

Order order = member.getOrder();
order.getOrderDate();
```

4. JPA와 비교

JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다.

```java
String memberId = "100";
Member member1 = jpa.find(Member.class, memberId);
Member member2 = jpa.find(Member.class, memberId);

member1==member2; //같다.
```

## JPA란?

자바 진영의 ORM 기술 표준이다.

ORM이란?  
객체와 관계형 데이터 베이스를 매핑한다는 뜻
ORM 프레임워크는 단순히 SQL을 개발자 대신 생성해서 데이터베이스에 전달 해주는 것 뿐만 아니라 다양한 패러다임의 불일치 문제들도 해결

## JPA를 사용해야 하는 이유

- 생산성
    JPA를 사용하면 자바 컬렉션에서 객체를 저장하듯이 JPA에게 저장 할 객체를 전달하면 된다.  ⇒ 지루하고 반복적인 일을 대신 처리해줌

- 유지보수
    엔티티에 필드를 하나만 추가해도 관련된 등록, 수정, 조회를 위해 코드를 변경을 위해 코드를 모두 변경할 필요가 없다.

- 패러다임의 불일치 해결
    JPA는 상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 패러다임의 문제를 해결

- 성능
    애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공

- 데이터 접근 추상화와 벤더 독립성
    관계형 데이터베이스는 같은 기능도 벤더마다 사용법이 다른 경우가 많아 사용법을 각각 배워야하는 문제점을 JPA가 해결해준다.

- 표준
    JPA는 자바진영의 ORM기술 표본이기 때문에 다른 구현 기술로 손쉽게 변경가능